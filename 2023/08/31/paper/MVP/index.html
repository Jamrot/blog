<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Hexo | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Hexo</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
    
        <div class="post-main-title">
            USENIX Security&#39;20 MVP
        </div>
        <div class="post-meta">
            2023-08-31
        </div>
        <div class="post-md">
            <h1 id="USENIX-Security’20-MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures"><a href="#USENIX-Security’20-MVP-Detecting-Vulnerabilities-using-Patch-Enhanced-Vulnerability-Signatures" class="headerlink" title="USENIX Security’20 MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures"></a>USENIX Security’20 MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures</h1><p>重复漏洞（Recurring vulnerability）通常由于代码重用或者共用代码逻辑导致。但漏洞函数和修复函数之间的差别可能很小，而漏洞函数和目标函数之间的差别可能很大，给通常用于检测重复漏洞的方法clone-based和function matching-based带来了挑战。</p>
<p>作者提出了一种新方法MVP（针对C&#x2F;C++源代码），分别从切片后的vulnerable function和patched function内提取语法syntactic和语义semantic层面的vulnerable signature和patch signature。如果目标函数匹配vulnerable signature但不匹配patch signature，则认为函数内存在潜在漏洞。</p>
<p>作者在10个开源系统中进行了测试，结果显示，1) MVP比clone-based和function matching-based两种方法的SOTA表现得都要好，2) MVP可以检测到通用的漏洞检测方法检测不到的漏洞，3) MVP发现了97个新漏洞，收到23个CVE认证。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Challenges.</strong> 1) 如何通过识别已经修复的漏洞减少FP，2) 如何准确地产生已知漏洞的signature减少FP和FN。</p>
<p>本文通过1) 分别生成patch signature来区分函数是否被修复，解决第一个挑战；通过2) 新的切片技术仅提取与漏洞相关和补丁相关的语句，以在语法级别和语义级别生成漏洞和补丁签名，解决第二个挑战；并且3) 应用statement abstraction和entropy-based statement selection提高MVP的准确性</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Evaluation.</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> 1) 与2个clone-based方法对比，2) 与2个function matching-based方法对比，3) 与2个learning-based方法和2个商业工具对比</p>
<p><strong><strong><strong><strong><strong><strong>Contribution.</strong></strong></strong></strong></strong></strong> </p>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><img src="/2023/08/31/paper/MVP/overview.png" class="">

<p>提取函数签名 extracting function signature：提取目标系统中每个函数的签名</p>
<ul>
<li>使用Joern生成code property graph，提取function。并对每个函数生成AST和PDG (program dependence graph, 程序依赖图)。</li>
<li>抽象化：使用normalized symble (PARAM, VARIABLE, STRING) 代替具体的参数、变量和字符串。删除注释、空格等。</li>
<li>计算statements的哈希值→$f_{syn}$，根据PDF提取数据&#x2F;控制依赖关系→$f_{sem}$。</li>
</ul>
<img src="/2023/08/31/paper/MVP/case1.png" class=""> 

<img src="/2023/08/31/paper/MVP/case2.png" class="">

<p>提取漏洞和补丁签名 extracting vulnerability and patch signature：提取补丁中的漏洞签名和补丁签名</p>
<ul>
<li>确定补丁修改的函数及函数内的代码变化</li>
<li>新的切片方法用于更准确地确定漏洞相关代码：正常的PDG后向切片(backward slicing)，根据不同statement (assignment, conditional, return, others)自定义的PDG前向切片(forward slicing)策略。</li>
</ul>
<p>检测漏洞 detecting vulnerability：通过比较目标函数签名与漏洞和补丁签名，判断是否存在漏洞。</p>
<ul>
<li>目标函数包含所有deleted statements, 且目标函数签名匹配漏洞签名（|V∩f|&#x2F;|V|&gt;t），不匹配补丁签名（|P∩f|&#x2F;|P|≤t）。</li>
</ul>
<p>*function signature $(f_{syn}, f_{sem})$, $f_{syn}$-all statements, $f_{sem}$ - $(h_1, h_2, type)$ - statement(h1), statement(h2), data&#x2F;control(type) .</p>
<p>*deleted statements: 补丁中删除的代码行</p>
<p>*匹配 match：thresholds &#x3D; 0.8</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>准确率，检测规模 scalability，thresholds sensitivity，语句抽象和语句信息如何影响MVP的准确性，通用漏洞检测方法在重复漏洞中的检测效果。</p>
<p><strong>False Positive.</strong> 1) 缺失过程间分析inter-procedure的调用上下文calling-context，一些在函数调用前的check没有发现；2) 语义等价没有被建模；3) 签名中没有包含漏洞的根本原因。</p>
<p><strong>False Negative.</strong> 1) MVP检测粒度为函数级别而不是hunk级别，所以当提取签名时会有更多noise；2) 没有对数据类型和函数调用抽象化。</p>
<h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h2><p>1、无法检测Type-4（两个功能类似）的重复漏洞</p>
<p>3、无法检测由于struct或macro导致的漏洞</p>
<blockquote>
<p>Third, we cannot detect vulnerabilities whose patches are out of functions. Some vulnerabilities are fixed by only changing struct or macro, which are out of functions.</p>
</blockquote>
<ul>
<li><p>解决对数据类型和函数调用抽象化（FN 2）</p>
<p>  首先对每个statement（包括数据类型和函数调用）抽象化并计算哈希值，通过哈希值匹配目标和漏洞的statement；如果匹配成功，则将statement的每个token都用tokenize的向量表示，再计算相似度；若相似度大于某个阈值，且满足MVP的匹配过程，则认为该函数可能有漏洞。</p>
</li>
</ul>
<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><ol>
<li><p>检测粒度？</p>
<ul>
<li>函数</li>
</ul>
</li>
<li><p>语法和语义层面的signature分别是什么？</p>
<ul>
<li>语法syntactic层面：一个句子；语义semantic层面：结构（数据流图）</li>
</ul>
</li>
<li><p>如何确定漏洞函数和目标函数？</p>
<ul>
<li>漏洞函数即patch修改中被删除代码行的函数，目标函数指目标系统的全部函数。</li>
</ul>
</li>
<li><p>如何切片？</p>
<ul>
<li>正常的PDG后向切片(backward slicing)+根据不同statement (assignment, conditional, return, others)自定义的PDG前向切片(forward slicing)策略 $3.3.2。</li>
</ul>
</li>
<li><p>怎么判断是否匹配？</p>
<ul>
<li>$3.4</li>
</ul>
</li>
<li><p>该方法比其他方法好的原因是什么？</p>
<ul>
<li>作者进行的预实验表明，大部分patched function和vulnerable function之间的差别很小，所以只使用vulnarable signature的clone-based approaches可能会把patched function错误识别为vulnerable function导致FP。→ MVP同时使用了vulnerability signature和patch signature，用于区分函数是否被修复，减少FP。【具体可以看motivating example】</li>
<li>当vulnerable function和target function之间相似度小（差别很大）时，function matching-based approaches无法识别出目标函数，造成FN。→MVP使用新的切片技术，生成语法和语义级别的signature，减少FP和FN。</li>
<li>应用statement abstraction和entropy-based statement selection提高准确性。</li>
</ul>
</li>
<li><p>如何收集patch和ground-truth？</p>
<ul>
<li>Patch：NVD+commit</li>
</ul>
<blockquote>
<p>To enrich the dataset, we obtained the commits which contain secretly patched vulnerabilities from our industrial collaborator.</p>
</blockquote>
<ul>
<li>ground-truth：所有工具检测出来的true positive之和</li>
</ul>
</li>
</ol>

        </div>

    

</div>
                <div class="footer">
    <span>Copyright © 2022 Hexo</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這李設計</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>